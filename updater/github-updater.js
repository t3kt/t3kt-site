// Generated by CoffeeScript 1.6.3
(function() {
  var Deferred, GithubUpdater, NOT_IMPLEMENTED, SourceUpdater, config, createItem, db, moment, parseLinkHeader, retrieveCommitBatch, sourceKey, typeKey, util, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  config = require('../config/config');

  util = require('../models/util');

  NOT_IMPLEMENTED = util.NOT_IMPLEMENTED;

  db = require('../models/db');

  moment = require('moment');

  Deferred = require('Deferred');

  SourceUpdater = require('./index').SourceUpdater;

  createItem = require('./index').createItem;

  parseLinkHeader = require('./linkheaders').parse;

  retrieveCommitBatch = function(url, callback) {
    return util.requestAsync(url).pipe(function(body, response) {
      var commits;
      commits = JSON.parse(body);
      return util.when(callback(commits)).done(function(result) {
        var header, link, links, next;
        if (result === false) {
          return;
        }
        header = response.hasHeader('link', null);
        header = header && response.headers[header];
        links = header && parseLinksHeader(header);
        if (links) {
          next = ((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = links.length; _i < _len; _i++) {
              link = links[_i];
              if (link.rel === 'next') {
                _results.push(link.href);
              }
            }
            return _results;
          })())[0];
          if (next) {
            return retrieveCommitBatch(next, callback);
          }
        }
      });
    });
  };

  sourceKey = 'github';

  typeKey = 'commit';

  GithubUpdater = (function(_super) {
    __extends(GithubUpdater, _super);

    function GithubUpdater() {
      _ref = GithubUpdater.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    GithubUpdater.typeKey = typeKey;

    GithubUpdater.sourceKey = sourceKey;

    GithubUpdater.prototype.createDefinition = function() {
      return {
        key: sourceKey,
        types: [typeKey],
        config: {}
      };
    };

    GithubUpdater.prototype.updateProject = function(project) {
      var repoUrl;
      if (!project.githubRepo) {
        return Deferred.when();
      } else {
        repoUrl = "https://api.github.com/repos/t3kt/" + project.githubRepo;
        return util.requestAsync(repoUrl).pipe(function(body) {
          var repo;
          repo = JSON.parse(body);
          return retrieveCommitBatch(repoUrl + "/commits?per_page=50", function(commits) {
            var extId, obj, results;
            results = (function() {
              var _i, _len, _results;
              _results = [];
              for (_i = 0, _len = commits.length; _i < _len; _i++) {
                obj = commits[_i];
                extId = "" + repo.id + ":" + obj.sha;
                _results.push(db.asyncFindOne('items', [
                  {
                    type: typeKey,
                    source: sourceKey,
                    externalId: extId
                  }
                ]).pipe(function(exists) {
                  var commit;
                  if (exists) {
                    return;
                  }
                  commit = createItem(typeKey, sourceKey, extId, {
                    detailUrl: obj.html_url,
                    posted: moment(obj.commit.committer.date).toDate(),
                    title: obj.commit.message,
                    projects: [project.key]
                  });
                  return db.insertItem(commit);
                }));
              }
              return _results;
            })();
            return util.whenAll(results);
          });
        });
      }
    };

    return GithubUpdater;

  })(SourceUpdater);

  module.exports = GithubUpdater;

}).call(this);
