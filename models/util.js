// Generated by CoffeeScript 1.6.3
(function() {
  var Batcher, Deferred, request,
    __slice = [].slice;

  request = require('request');

  Deferred = require('Deferred');

  module.exports = {
    NOT_IMPLEMENTED: function(msg) {
      throw new Error("Not implemented: " + (msg || '') + "...");
    },
    DBG_DEFERRED: function(dfd) {
      return dfd.done(function(x) {
        return console.log('DONE', x);
      }).fail(function(x) {
        return console.log('FAIL', x);
      });
    },
    compare: function(a, b) {
      if (a === b) {
        return 0;
      }
      if (a < b) {
        return -1;
      } else {
        return 1;
      }
    },
    requestAsync: function(url) {
      console.log("making request: " + url);
      return Deferred(function(dfd) {
        return request(url, function(error, response, body) {
          if (error) {
            return dfd.reject(error);
          } else {
            return dfd.resolve(body, response);
          }
        });
      });
    },
    limitSize: function(size, maxSize) {
      var aspect, height, width;
      aspect = size.width / size.height;
      width = size.width, height = size.height;
      if (maxSize.width && width > maxSize.width) {
        width = maxSize.width;
        height = maxSize.width / aspect;
      }
      if (maxSize.height && height > maxSize.height) {
        height = maxSize.height;
        width = maxSize.height * aspect;
      }
      return {
        width: width,
        height: height
      };
    },
    throwError: function(err) {
      throw err;
    },
    when: Deferred.when,
    asArray: function(val) {
      if (!(val != null)) {
        return [];
      } else {
        if (Array.isArray(val)) {
          return val;
        } else {
          return [val];
        }
      }
    },
    whenAll: function() {
      return Deferred.when.apply(null, arguments);
    },
    reject: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return Deferred(function(dfd) {
        return dfd.rejectWith(dfd, args);
      });
    },
    Batcher: Batcher,
    batchItems: function(items, overrides) {
      return new Batcher(overrides).run(items);
    }
  };

  Batcher = (function() {
    function Batcher(overrides) {
      _.extend(this, overrides);
    }

    Batcher.prototype.startsNewBatch = function(item, batch) {
      return !(batch != null) || batch.type === item.type;
    };

    Batcher.prototype.createBatch = function(item) {
      return {
        type: item.type,
        items: [item]
      };
    };

    Batcher.prototype.addItem = function(item, batch) {
      return batch.items.push(item);
    };

    Batcher.prototype.run = function(items) {
      var batch, batches, item, _i, _len;
      batches = [];
      batch = null;
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        if (this.startsNewBatch(item, batch)) {
          batches.push(batch = this.createBatch(item));
        } else {
          this.addItem(item, batch);
        }
      }
      return batches;
    };

    return Batcher;

  })();

}).call(this);
