// Generated by CoffeeScript 1.6.3
(function() {
  var Deferred, E, NOT_IMPLEMENTED, asyncCall, asyncFindToArray, cache, config, connect, getItems, getProject, getProjectList, mongo, mongoClient, mongoDb, util, _,
    __slice = [].slice;

  _ = require('lodash');

  Deferred = require('Deferred');

  mongo = require('mongodb');

  config = require('../config/config');

  E = require('./entities');

  util = require('./util');

  NOT_IMPLEMENTED = util.NOT_IMPLEMENTED;

  cache = require('./cache');

  mongoClient = new mongo.MongoClient(new mongo.Server(config.mongoHost, config.mongoPort, config.mongoOptions));

  mongoDb = null;

  mongoClient.addListener(function() {
    return mongoDb = null;
  });

  connect = function() {
    if (mongoDb) {
      return Deferred.when(mongoDb);
    } else {
      return Deferred(function(dfd) {
        return mongoClient.open(function(err) {
          if (err) {
            return dfd.reject(err);
          } else {
            return dfd.resolve(mongoDb = mongoClient.db(config.mongoDbName));
          }
        });
      });
    }
  };

  asyncCall = function(collection, method, args) {
    return connect().pipe(function(db) {
      var coll;
      coll = db.collection(collection);
      return Deferred(function(dfd) {
        return coll[method].apply(coll, (args || []).concat(function(err, result) {
          if (err) {
            return dfd.reject(err);
          } else {
            return dfd.resolve(result);
          }
        }));
      });
    });
  };

  asyncFindToArray = function(collection, args) {
    return asyncCall(collection, 'find', args).pipe(function(cur) {
      return Deferred(function(dfd) {
        return cur.toArray(function(err, docs) {
          if (err) {
            return dfd.reject(err);
          } else {
            return dfd.resolve(docs);
          }
        });
      });
    });
  };

  getProjectList = function() {
    return cache.getOrLoadAsync('projects', function() {
      return asyncFindToArray('projects', [
        {}, {
          sort: [['order', 1], ['key', 2]]
        }
      ]);
    }).done(function(list) {
      return list.forEach(function(project) {
        return cache.add('project:' + project.key, project);
      });
    });
  };

  getProject = function(key) {
    return cache.getAsync('project:' + key).pipe(null, function() {
      return getProjectList().pipe(function() {
        return cache.get('project:' + key);
      });
    });
  };

  getItems = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return asyncFindToArray('items', args);
  };

  exports.getProjectList = getProjectList;

  exports.getProject = getProject;

  exports.getItems = getItems;

  exports.getProjectItems = function(projectKey, type) {
    var query;
    query = {
      project: projectKey
    };
    if (type) {
      query.type = type;
    }
    return getItems(query);
  };

}).call(this);
